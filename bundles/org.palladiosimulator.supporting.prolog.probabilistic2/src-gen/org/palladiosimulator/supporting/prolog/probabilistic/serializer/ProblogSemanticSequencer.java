/*
 * generated by Xtext 2.23.0
 */
package org.palladiosimulator.supporting.prolog.probabilistic.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.palladiosimulator.supporting.prolog.model.prolog.AtomicDouble;
import org.palladiosimulator.supporting.prolog.model.prolog.AtomicNumber;
import org.palladiosimulator.supporting.prolog.model.prolog.AtomicQuotedString;
import org.palladiosimulator.supporting.prolog.model.prolog.Comment;
import org.palladiosimulator.supporting.prolog.model.prolog.CompoundTerm;
import org.palladiosimulator.supporting.prolog.model.prolog.Cut;
import org.palladiosimulator.supporting.prolog.model.prolog.Fact;
import org.palladiosimulator.supporting.prolog.model.prolog.Fail;
import org.palladiosimulator.supporting.prolog.model.prolog.False;
import org.palladiosimulator.supporting.prolog.model.prolog.List;
import org.palladiosimulator.supporting.prolog.model.prolog.Program;
import org.palladiosimulator.supporting.prolog.model.prolog.PrologPackage;
import org.palladiosimulator.supporting.prolog.model.prolog.Rule;
import org.palladiosimulator.supporting.prolog.model.prolog.True;
import org.palladiosimulator.supporting.prolog.model.prolog.directives.DirectivesPackage;
import org.palladiosimulator.supporting.prolog.model.prolog.directives.Discontiguous;
import org.palladiosimulator.supporting.prolog.model.prolog.directives.Dynamic;
import org.palladiosimulator.supporting.prolog.model.prolog.directives.Multifile;
import org.palladiosimulator.supporting.prolog.model.prolog.directives.PredicateIndicator;
import org.palladiosimulator.supporting.prolog.model.prolog.directives.Public;
import org.palladiosimulator.supporting.prolog.model.prolog.directives.Table;
import org.palladiosimulator.supporting.prolog.model.prolog.directives.Volatile;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.As;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.BinaryAnd;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.BinaryOr;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.BitwiseNegation;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.BitwiseShiftLeft;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Condition;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Disequality;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Div;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Division;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.EqualOrStandardOrderAfter;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.EqualOrStandardOrderBefore;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Equivalence;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.ExpressionsPackage;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.GreaterOrEqual;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.GreaterThan;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.IntegerDivision;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Is;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.LessOrEqual;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.LessThan;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.LogicalAnd;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.LogicalOr;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Minus;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Mod;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.ModuleCall;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Multiplication;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.NegativeNumber;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.NonEqualNumber;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.NotProvable;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.NotUnifiable;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.NumberEqual;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.ParticalUnification;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Plus;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.PositiveNumber;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Power;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Rdiv;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Rem;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.SoftCut;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.StandardOrderAfter;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.StandardOrderBefore;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.StructuralEquivalence;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.StructuralEquivalenceNotProvable;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.SubDict;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Unification;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Univ;
import org.palladiosimulator.supporting.prolog.model.prolog.expressions.Xor;
import org.palladiosimulator.supporting.prolog.probabilistic.model.problog.AnnotatedDisjunction;
import org.palladiosimulator.supporting.prolog.probabilistic.model.problog.ProbabilisticFact;
import org.palladiosimulator.supporting.prolog.probabilistic.model.problog.ProbabilisticRule;
import org.palladiosimulator.supporting.prolog.probabilistic.model.problog.ProblogPackage;
import org.palladiosimulator.supporting.prolog.probabilistic.services.ProblogGrammarAccess;
import org.palladiosimulator.supporting.prolog.serializer.PrologSemanticSequencer;

@SuppressWarnings("all")
public class ProblogSemanticSequencer extends PrologSemanticSequencer {

	@Inject
	private ProblogGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DirectivesPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DirectivesPackage.DISCONTIGUOUS:
				sequence_ListDirectives(context, (Discontiguous) semanticObject); 
				return; 
			case DirectivesPackage.DYNAMIC:
				sequence_ListDirectives(context, (Dynamic) semanticObject); 
				return; 
			case DirectivesPackage.MULTIFILE:
				sequence_ListDirectives(context, (Multifile) semanticObject); 
				return; 
			case DirectivesPackage.PREDICATE_INDICATOR:
				sequence_PredicateIndicator(context, (PredicateIndicator) semanticObject); 
				return; 
			case DirectivesPackage.PUBLIC:
				sequence_ListDirectives(context, (Public) semanticObject); 
				return; 
			case DirectivesPackage.TABLE:
				sequence_TableDirective(context, (Table) semanticObject); 
				return; 
			case DirectivesPackage.VOLATILE:
				sequence_ListDirectives(context, (Volatile) semanticObject); 
				return; 
			}
		else if (epackage == ExpressionsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ExpressionsPackage.AS:
				sequence_Expression_700_xfx(context, (As) semanticObject); 
				return; 
			case ExpressionsPackage.BINARY_AND:
				sequence_Expression_500_yfx(context, (BinaryAnd) semanticObject); 
				return; 
			case ExpressionsPackage.BINARY_OR:
				sequence_Expression_500_yfx(context, (BinaryOr) semanticObject); 
				return; 
			case ExpressionsPackage.BITWISE_NEGATION:
				sequence_Expression_200_fy(context, (BitwiseNegation) semanticObject); 
				return; 
			case ExpressionsPackage.BITWISE_SHIFT_LEFT:
				sequence_Expression_400_yfx(context, (BitwiseShiftLeft) semanticObject); 
				return; 
			case ExpressionsPackage.CONDITION:
				sequence_Expression_1050_xfy(context, (Condition) semanticObject); 
				return; 
			case ExpressionsPackage.DISEQUALITY:
				sequence_Expression_700_xfx(context, (Disequality) semanticObject); 
				return; 
			case ExpressionsPackage.DIV:
				sequence_Expression_400_yfx(context, (Div) semanticObject); 
				return; 
			case ExpressionsPackage.DIVISION:
				sequence_Expression_400_yfx(context, (Division) semanticObject); 
				return; 
			case ExpressionsPackage.EQUAL_OR_STANDARD_ORDER_AFTER:
				sequence_Expression_700_xfx(context, (EqualOrStandardOrderAfter) semanticObject); 
				return; 
			case ExpressionsPackage.EQUAL_OR_STANDARD_ORDER_BEFORE:
				sequence_Expression_700_xfx(context, (EqualOrStandardOrderBefore) semanticObject); 
				return; 
			case ExpressionsPackage.EQUIVALENCE:
				sequence_Expression_700_xfx(context, (Equivalence) semanticObject); 
				return; 
			case ExpressionsPackage.GREATER_OR_EQUAL:
				sequence_Expression_700_xfx(context, (GreaterOrEqual) semanticObject); 
				return; 
			case ExpressionsPackage.GREATER_THAN:
				sequence_Expression_700_xfx(context, (GreaterThan) semanticObject); 
				return; 
			case ExpressionsPackage.INTEGER_DIVISION:
				sequence_Expression_400_yfx(context, (IntegerDivision) semanticObject); 
				return; 
			case ExpressionsPackage.IS:
				sequence_Expression_700_xfx(context, (Is) semanticObject); 
				return; 
			case ExpressionsPackage.LESS_OR_EQUAL:
				sequence_Expression_700_xfx(context, (LessOrEqual) semanticObject); 
				return; 
			case ExpressionsPackage.LESS_THAN:
				sequence_Expression_700_xfx(context, (LessThan) semanticObject); 
				return; 
			case ExpressionsPackage.LOGICAL_AND:
				sequence_Expression_1000_xfy(context, (LogicalAnd) semanticObject); 
				return; 
			case ExpressionsPackage.LOGICAL_OR:
				sequence_Expression_1100_xfy(context, (LogicalOr) semanticObject); 
				return; 
			case ExpressionsPackage.MINUS:
				sequence_Expression_500_yfx(context, (Minus) semanticObject); 
				return; 
			case ExpressionsPackage.MOD:
				sequence_Expression_400_yfx(context, (Mod) semanticObject); 
				return; 
			case ExpressionsPackage.MODULE_CALL:
				sequence_Expression_600_xfy(context, (ModuleCall) semanticObject); 
				return; 
			case ExpressionsPackage.MULTIPLICATION:
				sequence_Expression_400_yfx(context, (Multiplication) semanticObject); 
				return; 
			case ExpressionsPackage.NEGATIVE_NUMBER:
				sequence_Expression_200_fy(context, (NegativeNumber) semanticObject); 
				return; 
			case ExpressionsPackage.NON_EQUAL_NUMBER:
				sequence_Expression_700_xfx(context, (NonEqualNumber) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_PROVABLE:
				sequence_Expression_900_fy(context, (NotProvable) semanticObject); 
				return; 
			case ExpressionsPackage.NOT_UNIFIABLE:
				sequence_Expression_700_xfx(context, (NotUnifiable) semanticObject); 
				return; 
			case ExpressionsPackage.NUMBER_EQUAL:
				sequence_Expression_700_xfx(context, (NumberEqual) semanticObject); 
				return; 
			case ExpressionsPackage.PARTICAL_UNIFICATION:
				sequence_Expression_700_xfx(context, (ParticalUnification) semanticObject); 
				return; 
			case ExpressionsPackage.PLUS:
				sequence_Expression_500_yfx(context, (Plus) semanticObject); 
				return; 
			case ExpressionsPackage.POSITIVE_NUMBER:
				sequence_Expression_200_fy(context, (PositiveNumber) semanticObject); 
				return; 
			case ExpressionsPackage.POWER:
				sequence_Expression_200_xfy(context, (Power) semanticObject); 
				return; 
			case ExpressionsPackage.RDIV:
				sequence_Expression_400_yfx(context, (Rdiv) semanticObject); 
				return; 
			case ExpressionsPackage.REM:
				sequence_Expression_400_yfx(context, (Rem) semanticObject); 
				return; 
			case ExpressionsPackage.SOFT_CUT:
				sequence_Expression_1050_xfy(context, (SoftCut) semanticObject); 
				return; 
			case ExpressionsPackage.STANDARD_ORDER_AFTER:
				sequence_Expression_700_xfx(context, (StandardOrderAfter) semanticObject); 
				return; 
			case ExpressionsPackage.STANDARD_ORDER_BEFORE:
				sequence_Expression_700_xfx(context, (StandardOrderBefore) semanticObject); 
				return; 
			case ExpressionsPackage.STRUCTURAL_EQUIVALENCE:
				sequence_Expression_700_xfx(context, (StructuralEquivalence) semanticObject); 
				return; 
			case ExpressionsPackage.STRUCTURAL_EQUIVALENCE_NOT_PROVABLE:
				sequence_Expression_700_xfx(context, (StructuralEquivalenceNotProvable) semanticObject); 
				return; 
			case ExpressionsPackage.SUB_DICT:
				sequence_Expression_700_xfx(context, (SubDict) semanticObject); 
				return; 
			case ExpressionsPackage.UNIFICATION:
				sequence_Expression_700_xfx(context, (Unification) semanticObject); 
				return; 
			case ExpressionsPackage.UNIV:
				sequence_Expression_700_xfx(context, (Univ) semanticObject); 
				return; 
			case ExpressionsPackage.XOR:
				sequence_Expression_500_yfx(context, (Xor) semanticObject); 
				return; 
			}
		else if (epackage == ProblogPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ProblogPackage.ANNOTATED_DISJUNCTION:
				sequence_AnnotatedDisjunction(context, (AnnotatedDisjunction) semanticObject); 
				return; 
			case ProblogPackage.PROBABILISTIC_FACT:
				sequence_ProbabilisticFact(context, (ProbabilisticFact) semanticObject); 
				return; 
			case ProblogPackage.PROBABILISTIC_RULE:
				sequence_ProbabilisticRule(context, (ProbabilisticRule) semanticObject); 
				return; 
			}
		else if (epackage == PrologPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case PrologPackage.ATOMIC_DOUBLE:
				sequence_AtomicDouble(context, (AtomicDouble) semanticObject); 
				return; 
			case PrologPackage.ATOMIC_NUMBER:
				sequence_AtomicNumber(context, (AtomicNumber) semanticObject); 
				return; 
			case PrologPackage.ATOMIC_QUOTED_STRING:
				sequence_AtomicQuotedString(context, (AtomicQuotedString) semanticObject); 
				return; 
			case PrologPackage.COMMENT:
				sequence_Comment(context, (Comment) semanticObject); 
				return; 
			case PrologPackage.COMPOUND_TERM:
				sequence_CompoundTerm(context, (CompoundTerm) semanticObject); 
				return; 
			case PrologPackage.CUT:
				sequence_Cut(context, (Cut) semanticObject); 
				return; 
			case PrologPackage.FACT:
				sequence_TermClause(context, (Fact) semanticObject); 
				return; 
			case PrologPackage.FAIL:
				sequence_Fail(context, (Fail) semanticObject); 
				return; 
			case PrologPackage.FALSE:
				sequence_False(context, (False) semanticObject); 
				return; 
			case PrologPackage.LIST:
				sequence_List(context, (List) semanticObject); 
				return; 
			case PrologPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case PrologPackage.RULE:
				sequence_TermClause(context, (Rule) semanticObject); 
				return; 
			case PrologPackage.TRUE:
				sequence_True(context, (True) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     ProblogClause returns AnnotatedDisjunction
	 *     AnnotatedDisjunction returns AnnotatedDisjunction
	 *
	 * Constraint:
	 *     (probablisticFacts+=ProbabilisticFact probablisticFacts+=ProbabilisticFact* body=Expression_1100_xfy?)
	 */
	protected void sequence_AnnotatedDisjunction(ISerializationContext context, AnnotatedDisjunction semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProblogClause returns ProbabilisticFact
	 *     ProbFactRule returns ProbabilisticFact
	 *     ProbabilisticFact returns ProbabilisticFact
	 *
	 * Constraint:
	 *     (probability=PROBABILITY? head=CompoundTerm)
	 */
	protected void sequence_ProbabilisticFact(ISerializationContext context, ProbabilisticFact semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ProblogClause returns ProbabilisticRule
	 *     ProbFactRule returns ProbabilisticRule
	 *     ProbabilisticRule returns ProbabilisticRule
	 *
	 * Constraint:
	 *     (probability=PROBABILITY? head=CompoundTerm body=Expression_1100_xfy)
	 */
	protected void sequence_ProbabilisticRule(ISerializationContext context, ProbabilisticRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     clauses+=ProblogClause+
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
