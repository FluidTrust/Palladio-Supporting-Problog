/*
 * generated by Xtext 2.23.0
 */
package org.palladiosimulator.supporting.prolog.probabilistic.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;
import org.palladiosimulator.supporting.prolog.services.PrologGrammarAccess;

@Singleton
public class ProblogGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class ProgramElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.supporting.prolog.probabilistic.Problog.Program");
		private final Assignment cClausesAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cClausesProblogClauseParserRuleCall_0 = (RuleCall)cClausesAssignment.eContents().get(0);
		
		//@Override
		//Program prolog::Program:
		//	clauses+=ProblogClause*;
		@Override public ParserRule getRule() { return rule; }
		
		//clauses+=ProblogClause*
		public Assignment getClausesAssignment() { return cClausesAssignment; }
		
		//ProblogClause
		public RuleCall getClausesProblogClauseParserRuleCall_0() { return cClausesProblogClauseParserRuleCall_0; }
	}
	public class ProblogClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.supporting.prolog.probabilistic.Problog.ProblogClause");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cAlternatives.eContents().get(0);
		private final Alternatives cAlternatives_0_0 = (Alternatives)cGroup_0.eContents().get(0);
		private final RuleCall cProbFactRuleParserRuleCall_0_0_0 = (RuleCall)cAlternatives_0_0.eContents().get(0);
		private final RuleCall cAnnotatedDisjunctionParserRuleCall_0_0_1 = (RuleCall)cAlternatives_0_0.eContents().get(1);
		private final RuleCall cTermClauseParserRuleCall_0_0_2 = (RuleCall)cAlternatives_0_0.eContents().get(2);
		private final RuleCall cPredicateParserRuleCall_0_0_3 = (RuleCall)cAlternatives_0_0.eContents().get(3);
		private final Keyword cFullStopKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final RuleCall cCommentParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ProblogClause prolog::Clause:
		//	(ProbFactRule | AnnotatedDisjunction | TermClause | Predicate) '.' | Comment;
		@Override public ParserRule getRule() { return rule; }
		
		//(ProbFactRule | AnnotatedDisjunction | TermClause | Predicate) '.' | Comment
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//(ProbFactRule | AnnotatedDisjunction | TermClause | Predicate) '.'
		public Group getGroup_0() { return cGroup_0; }
		
		//(ProbFactRule | AnnotatedDisjunction | TermClause | Predicate)
		public Alternatives getAlternatives_0_0() { return cAlternatives_0_0; }
		
		//ProbFactRule
		public RuleCall getProbFactRuleParserRuleCall_0_0_0() { return cProbFactRuleParserRuleCall_0_0_0; }
		
		//AnnotatedDisjunction
		public RuleCall getAnnotatedDisjunctionParserRuleCall_0_0_1() { return cAnnotatedDisjunctionParserRuleCall_0_0_1; }
		
		//TermClause
		public RuleCall getTermClauseParserRuleCall_0_0_2() { return cTermClauseParserRuleCall_0_0_2; }
		
		//Predicate
		public RuleCall getPredicateParserRuleCall_0_0_3() { return cPredicateParserRuleCall_0_0_3; }
		
		//'.'
		public Keyword getFullStopKeyword_0_1() { return cFullStopKeyword_0_1; }
		
		//Comment
		public RuleCall getCommentParserRuleCall_1() { return cCommentParserRuleCall_1; }
	}
	public class ProbFactRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.supporting.prolog.probabilistic.Problog.ProbFactRule");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cProbabilisticFactParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cProbabilisticRuleParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		//ProbFactRule prolog::Clause:
		//	ProbabilisticFact | ProbabilisticRule;
		@Override public ParserRule getRule() { return rule; }
		
		//ProbabilisticFact | ProbabilisticRule
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ProbabilisticFact
		public RuleCall getProbabilisticFactParserRuleCall_0() { return cProbabilisticFactParserRuleCall_0; }
		
		//ProbabilisticRule
		public RuleCall getProbabilisticRuleParserRuleCall_1() { return cProbabilisticRuleParserRuleCall_1; }
	}
	public class AnnotatedDisjunctionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.supporting.prolog.probabilistic.Problog.AnnotatedDisjunction");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cProbablisticFactsAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cProbablisticFactsProbabilisticFactParserRuleCall_0_0 = (RuleCall)cProbablisticFactsAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final Keyword cSemicolonKeyword_1_0 = (Keyword)cGroup_1.eContents().get(0);
		private final Assignment cProbablisticFactsAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cProbablisticFactsProbabilisticFactParserRuleCall_1_1_0 = (RuleCall)cProbablisticFactsAssignment_1_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final Keyword cColonHyphenMinusKeyword_2_0 = (Keyword)cGroup_2.eContents().get(0);
		private final Assignment cBodyAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cBodyExpression_1100_xfyParserRuleCall_2_1_0 = (RuleCall)cBodyAssignment_2_1.eContents().get(0);
		
		//AnnotatedDisjunction:
		//	probablisticFacts+=ProbabilisticFact (';' probablisticFacts+=ProbabilisticFact)* (':-' body=Expression_1100_xfy)?;
		@Override public ParserRule getRule() { return rule; }
		
		//probablisticFacts+=ProbabilisticFact (';' probablisticFacts+=ProbabilisticFact)* (':-' body=Expression_1100_xfy)?
		public Group getGroup() { return cGroup; }
		
		//probablisticFacts+=ProbabilisticFact
		public Assignment getProbablisticFactsAssignment_0() { return cProbablisticFactsAssignment_0; }
		
		//ProbabilisticFact
		public RuleCall getProbablisticFactsProbabilisticFactParserRuleCall_0_0() { return cProbablisticFactsProbabilisticFactParserRuleCall_0_0; }
		
		//(';' probablisticFacts+=ProbabilisticFact)*
		public Group getGroup_1() { return cGroup_1; }
		
		//';'
		public Keyword getSemicolonKeyword_1_0() { return cSemicolonKeyword_1_0; }
		
		//probablisticFacts+=ProbabilisticFact
		public Assignment getProbablisticFactsAssignment_1_1() { return cProbablisticFactsAssignment_1_1; }
		
		//ProbabilisticFact
		public RuleCall getProbablisticFactsProbabilisticFactParserRuleCall_1_1_0() { return cProbablisticFactsProbabilisticFactParserRuleCall_1_1_0; }
		
		//(':-' body=Expression_1100_xfy)?
		public Group getGroup_2() { return cGroup_2; }
		
		//':-'
		public Keyword getColonHyphenMinusKeyword_2_0() { return cColonHyphenMinusKeyword_2_0; }
		
		//body=Expression_1100_xfy
		public Assignment getBodyAssignment_2_1() { return cBodyAssignment_2_1; }
		
		//Expression_1100_xfy
		public RuleCall getBodyExpression_1100_xfyParserRuleCall_2_1_0() { return cBodyExpression_1100_xfyParserRuleCall_2_1_0; }
	}
	public class ProbabilisticFactElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.supporting.prolog.probabilistic.Problog.ProbabilisticFact");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cProbabilityAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cProbabilityPROBABILITYTerminalRuleCall_0_0_0 = (RuleCall)cProbabilityAssignment_0_0.eContents().get(0);
		private final Keyword cColonColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadCompoundTermParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		
		//ProbabilisticFact:
		//	(probability=PROBABILITY '::')? head=CompoundTerm;
		@Override public ParserRule getRule() { return rule; }
		
		//(probability=PROBABILITY '::')? head=CompoundTerm
		public Group getGroup() { return cGroup; }
		
		//(probability=PROBABILITY '::')?
		public Group getGroup_0() { return cGroup_0; }
		
		//probability=PROBABILITY
		public Assignment getProbabilityAssignment_0_0() { return cProbabilityAssignment_0_0; }
		
		//PROBABILITY
		public RuleCall getProbabilityPROBABILITYTerminalRuleCall_0_0_0() { return cProbabilityPROBABILITYTerminalRuleCall_0_0_0; }
		
		//'::'
		public Keyword getColonColonKeyword_0_1() { return cColonColonKeyword_0_1; }
		
		//head=CompoundTerm
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//CompoundTerm
		public RuleCall getHeadCompoundTermParserRuleCall_1_0() { return cHeadCompoundTermParserRuleCall_1_0; }
	}
	public class ProbabilisticRuleElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.supporting.prolog.probabilistic.Problog.ProbabilisticRule");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cProbabilityAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cProbabilityPROBABILITYTerminalRuleCall_0_0_0 = (RuleCall)cProbabilityAssignment_0_0.eContents().get(0);
		private final Keyword cColonColonKeyword_0_1 = (Keyword)cGroup_0.eContents().get(1);
		private final Assignment cHeadAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cHeadCompoundTermParserRuleCall_1_0 = (RuleCall)cHeadAssignment_1.eContents().get(0);
		private final Keyword cColonHyphenMinusKeyword_2 = (Keyword)cGroup.eContents().get(2);
		private final Assignment cBodyAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cBodyExpression_1100_xfyParserRuleCall_3_0 = (RuleCall)cBodyAssignment_3.eContents().get(0);
		
		//ProbabilisticRule:
		//	(probability=PROBABILITY '::')? head=CompoundTerm ':-' body=Expression_1100_xfy;
		@Override public ParserRule getRule() { return rule; }
		
		//(probability=PROBABILITY '::')? head=CompoundTerm ':-' body=Expression_1100_xfy
		public Group getGroup() { return cGroup; }
		
		//(probability=PROBABILITY '::')?
		public Group getGroup_0() { return cGroup_0; }
		
		//probability=PROBABILITY
		public Assignment getProbabilityAssignment_0_0() { return cProbabilityAssignment_0_0; }
		
		//PROBABILITY
		public RuleCall getProbabilityPROBABILITYTerminalRuleCall_0_0_0() { return cProbabilityPROBABILITYTerminalRuleCall_0_0_0; }
		
		//'::'
		public Keyword getColonColonKeyword_0_1() { return cColonColonKeyword_0_1; }
		
		//head=CompoundTerm
		public Assignment getHeadAssignment_1() { return cHeadAssignment_1; }
		
		//CompoundTerm
		public RuleCall getHeadCompoundTermParserRuleCall_1_0() { return cHeadCompoundTermParserRuleCall_1_0; }
		
		//':-'
		public Keyword getColonHyphenMinusKeyword_2() { return cColonHyphenMinusKeyword_2; }
		
		//body=Expression_1100_xfy
		public Assignment getBodyAssignment_3() { return cBodyAssignment_3; }
		
		//Expression_1100_xfy
		public RuleCall getBodyExpression_1100_xfyParserRuleCall_3_0() { return cBodyExpression_1100_xfyParserRuleCall_3_0; }
	}
	
	
	private final ProgramElements pProgram;
	private final ProblogClauseElements pProblogClause;
	private final ProbFactRuleElements pProbFactRule;
	private final AnnotatedDisjunctionElements pAnnotatedDisjunction;
	private final ProbabilisticFactElements pProbabilisticFact;
	private final ProbabilisticRuleElements pProbabilisticRule;
	private final TerminalRule tPROBABILITY;
	
	private final Grammar grammar;
	
	private final PrologGrammarAccess gaProlog;

	@Inject
	public ProblogGrammarAccess(GrammarProvider grammarProvider,
			PrologGrammarAccess gaProlog) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaProlog = gaProlog;
		this.pProgram = new ProgramElements();
		this.pProblogClause = new ProblogClauseElements();
		this.pProbFactRule = new ProbFactRuleElements();
		this.pAnnotatedDisjunction = new AnnotatedDisjunctionElements();
		this.pProbabilisticFact = new ProbabilisticFactElements();
		this.pProbabilisticRule = new ProbabilisticRuleElements();
		this.tPROBABILITY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "org.palladiosimulator.supporting.prolog.probabilistic.Problog.PROBABILITY");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("org.palladiosimulator.supporting.prolog.probabilistic.Problog".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public PrologGrammarAccess getPrologGrammarAccess() {
		return gaProlog;
	}

	
	//@Override
	//Program prolog::Program:
	//	clauses+=ProblogClause*;
	public ProgramElements getProgramAccess() {
		return pProgram;
	}
	
	public ParserRule getProgramRule() {
		return getProgramAccess().getRule();
	}
	
	//ProblogClause prolog::Clause:
	//	(ProbFactRule | AnnotatedDisjunction | TermClause | Predicate) '.' | Comment;
	public ProblogClauseElements getProblogClauseAccess() {
		return pProblogClause;
	}
	
	public ParserRule getProblogClauseRule() {
		return getProblogClauseAccess().getRule();
	}
	
	//ProbFactRule prolog::Clause:
	//	ProbabilisticFact | ProbabilisticRule;
	public ProbFactRuleElements getProbFactRuleAccess() {
		return pProbFactRule;
	}
	
	public ParserRule getProbFactRuleRule() {
		return getProbFactRuleAccess().getRule();
	}
	
	//AnnotatedDisjunction:
	//	probablisticFacts+=ProbabilisticFact (';' probablisticFacts+=ProbabilisticFact)* (':-' body=Expression_1100_xfy)?;
	public AnnotatedDisjunctionElements getAnnotatedDisjunctionAccess() {
		return pAnnotatedDisjunction;
	}
	
	public ParserRule getAnnotatedDisjunctionRule() {
		return getAnnotatedDisjunctionAccess().getRule();
	}
	
	//ProbabilisticFact:
	//	(probability=PROBABILITY '::')? head=CompoundTerm;
	public ProbabilisticFactElements getProbabilisticFactAccess() {
		return pProbabilisticFact;
	}
	
	public ParserRule getProbabilisticFactRule() {
		return getProbabilisticFactAccess().getRule();
	}
	
	//ProbabilisticRule:
	//	(probability=PROBABILITY '::')? head=CompoundTerm ':-' body=Expression_1100_xfy;
	public ProbabilisticRuleElements getProbabilisticRuleAccess() {
		return pProbabilisticRule;
	}
	
	public ParserRule getProbabilisticRuleRule() {
		return getProbabilisticRuleAccess().getRule();
	}
	
	//terminal PROBABILITY returns ecore::EDouble:
	//	'1' | '0.' '0'..'9'+;
	public TerminalRule getPROBABILITYRule() {
		return tPROBABILITY;
	}
	
	//Clause:
	//	(Predicate | TermClause) '.' | Comment;
	public PrologGrammarAccess.ClauseElements getClauseAccess() {
		return gaProlog.getClauseAccess();
	}
	
	public ParserRule getClauseRule() {
		return getClauseAccess().getRule();
	}
	
	//Comment:
	//	value=PROLOG_SL_COMMENT;
	public PrologGrammarAccess.CommentElements getCommentAccess() {
		return gaProlog.getCommentAccess();
	}
	
	public ParserRule getCommentRule() {
		return getCommentAccess().getRule();
	}
	
	//Predicate Clause:
	//	':-' (TableDirective | ListDirectives);
	public PrologGrammarAccess.PredicateElements getPredicateAccess() {
		return gaProlog.getPredicateAccess();
	}
	
	public ParserRule getPredicateRule() {
		return getPredicateAccess().getRule();
	}
	
	//TableDirective directives::Table:
	//	'table' '(' predicate=PredicateIndicator ')';
	public PrologGrammarAccess.TableDirectiveElements getTableDirectiveAccess() {
		return gaProlog.getTableDirectiveAccess();
	}
	
	public ParserRule getTableDirectiveRule() {
		return getTableDirectiveAccess().getRule();
	}
	
	//ListDirectives directives::Directive:
	//	({directives::Dynamic} name='dynamic' | {directives::Discontiguous} name='discontiguous' | {directives::Multifile}
	//	name='multifile' | {directives::Public} name='public' | {directives::Volatile} name='volatile')
	//	'(' predicates+=PredicateIndicator (',' predicates+=PredicateIndicator)* ')';
	public PrologGrammarAccess.ListDirectivesElements getListDirectivesAccess() {
		return gaProlog.getListDirectivesAccess();
	}
	
	public ParserRule getListDirectivesRule() {
		return getListDirectivesAccess().getRule();
	}
	
	//PredicateIndicator directives::PredicateIndicator:
	//	name=(PROLOG_ID | PROLOG_STRING) '/' arity=INT;
	public PrologGrammarAccess.PredicateIndicatorElements getPredicateIndicatorAccess() {
		return gaProlog.getPredicateIndicatorAccess();
	}
	
	public ParserRule getPredicateIndicatorRule() {
		return getPredicateIndicatorAccess().getRule();
	}
	
	//TermClause Clause:
	//	CompoundTerm ({Fact.head=current} | {Rule.head=current} ':-' body=Expression_1100_xfy);
	public PrologGrammarAccess.TermClauseElements getTermClauseAccess() {
		return gaProlog.getTermClauseAccess();
	}
	
	public ParserRule getTermClauseRule() {
		return getTermClauseAccess().getRule();
	}
	
	//Term:
	//	CompoundTerm | AtomicNumber | AtomicDouble | AtomicQuotedString | List | ControlPredicate;
	public PrologGrammarAccess.TermElements getTermAccess() {
		return gaProlog.getTermAccess();
	}
	
	public ParserRule getTermRule() {
		return getTermAccess().getRule();
	}
	
	//CompoundTerm:
	//	value=PROLOG_ID ('(' arguments+=Expression_900_fy (',' arguments+=Expression_900_fy)* ')')?;
	public PrologGrammarAccess.CompoundTermElements getCompoundTermAccess() {
		return gaProlog.getCompoundTermAccess();
	}
	
	public ParserRule getCompoundTermRule() {
		return getCompoundTermAccess().getRule();
	}
	
	//AtomicNumber:
	//	value=INT;
	public PrologGrammarAccess.AtomicNumberElements getAtomicNumberAccess() {
		return gaProlog.getAtomicNumberAccess();
	}
	
	public ParserRule getAtomicNumberRule() {
		return getAtomicNumberAccess().getRule();
	}
	
	//AtomicDouble:
	//	value=Double;
	public PrologGrammarAccess.AtomicDoubleElements getAtomicDoubleAccess() {
		return gaProlog.getAtomicDoubleAccess();
	}
	
	public ParserRule getAtomicDoubleRule() {
		return getAtomicDoubleAccess().getRule();
	}
	
	//Double ecore::EDouble:
	//	INT '.' INT;
	public PrologGrammarAccess.DoubleElements getDoubleAccess() {
		return gaProlog.getDoubleAccess();
	}
	
	public ParserRule getDoubleRule() {
		return getDoubleAccess().getRule();
	}
	
	//AtomicQuotedString:
	//	value=PROLOG_STRING;
	public PrologGrammarAccess.AtomicQuotedStringElements getAtomicQuotedStringAccess() {
		return gaProlog.getAtomicQuotedStringAccess();
	}
	
	public ParserRule getAtomicQuotedStringRule() {
		return getAtomicQuotedStringAccess().getRule();
	}
	
	////AtomicID:
	////	value=PROLOG_ID
	////;
	//List:
	//	{List} '[' (heads+=Expression_900_fy (',' heads+=Expression_900_fy)* ('|' tails+=Expression_900_fy (','
	//	tails+=Expression_900_fy)*)?)? ']';
	public PrologGrammarAccess.ListElements getListAccess() {
		return gaProlog.getListAccess();
	}
	
	public ParserRule getListRule() {
		return getListAccess().getRule();
	}
	
	//ControlPredicate:
	//	True | False | Fail | Cut;
	public PrologGrammarAccess.ControlPredicateElements getControlPredicateAccess() {
		return gaProlog.getControlPredicateAccess();
	}
	
	public ParserRule getControlPredicateRule() {
		return getControlPredicateAccess().getRule();
	}
	
	//True:
	//	{True} 'true';
	public PrologGrammarAccess.TrueElements getTrueAccess() {
		return gaProlog.getTrueAccess();
	}
	
	public ParserRule getTrueRule() {
		return getTrueAccess().getRule();
	}
	
	//False:
	//	{False} 'false';
	public PrologGrammarAccess.FalseElements getFalseAccess() {
		return gaProlog.getFalseAccess();
	}
	
	public ParserRule getFalseRule() {
		return getFalseAccess().getRule();
	}
	
	//Fail:
	//	{Fail} 'fail';
	public PrologGrammarAccess.FailElements getFailAccess() {
		return gaProlog.getFailAccess();
	}
	
	public ParserRule getFailRule() {
		return getFailAccess().getRule();
	}
	
	//Cut:
	//	{Cut} '!';
	public PrologGrammarAccess.CutElements getCutAccess() {
		return gaProlog.getCutAccess();
	}
	
	public ParserRule getCutRule() {
		return getCutAccess().getRule();
	}
	
	//// logical OR, 1100, infix, left-associative
	//Expression_1100_xfy expressions::Expression:
	//	Expression_1050_xfy ({expressions::LogicalOr.left=current} /*(';'|'|')*/ ';' right=Expression_1050_xfy)*;
	public PrologGrammarAccess.Expression_1100_xfyElements getExpression_1100_xfyAccess() {
		return gaProlog.getExpression_1100_xfyAccess();
	}
	
	public ParserRule getExpression_1100_xfyRule() {
		return getExpression_1100_xfyAccess().getRule();
	}
	
	//// IF-THEN, 1050, infix, left-associative 
	//Expression_1050_xfy expressions::Expression:
	//	Expression_1000_xfy (({expressions::Condition.left=current} '->' | {expressions::SoftCut.left=current} '*->')
	//	right=Expression_1000_xfy)*;
	public PrologGrammarAccess.Expression_1050_xfyElements getExpression_1050_xfyAccess() {
		return gaProlog.getExpression_1050_xfyAccess();
	}
	
	public ParserRule getExpression_1050_xfyRule() {
		return getExpression_1050_xfyAccess().getRule();
	}
	
	//// logical AND, 1000, infix, left-associative
	//Expression_1000_xfy expressions::Expression:
	//	Expression_900_fy ({expressions::LogicalAnd.left=current} ',' right=Expression_900_fy)*;
	public PrologGrammarAccess.Expression_1000_xfyElements getExpression_1000_xfyAccess() {
		return gaProlog.getExpression_1000_xfyAccess();
	}
	
	public ParserRule getExpression_1000_xfyRule() {
		return getExpression_1000_xfyAccess().getRule();
	}
	
	//// 990, infix, non-associative
	///*
	//Expression_990_xfx returns Expression:
	//	Expression_900_fy ({Expression_990_xfx.left=current} ':=' right=Expression_900_fy)?
	//;
	//*/ // NOT_PROVABLE, 900, prefix, right-associative
	//Expression_900_fy expressions::Expression:
	//	Expression_700_xfx | {expressions::NotProvable} '\\+' expr=Expression_900_fy;
	public PrologGrammarAccess.Expression_900_fyElements getExpression_900_fyAccess() {
		return gaProlog.getExpression_900_fyAccess();
	}
	
	public ParserRule getExpression_900_fyRule() {
		return getExpression_900_fyAccess().getRule();
	}
	
	//// COMPARISONS, 700, infix, non-associative
	//Expression_700_xfx expressions::Expression:
	//	Expression_600_xfy (({expressions::LessThan.left=current} '<' | {expressions::Unification.left=current} '=' |
	//	{expressions::Univ.left=current} '=..' | {expressions::StructuralEquivalence.left=current} '=@=' |
	//	{expressions::StructuralEquivalenceNotProvable.left=current} '\\=@=' | {expressions::NumberEqual.left=current} '=:=' |
	//	{expressions::LessOrEqual.left=current} '=<' | {expressions::Equivalence.left=current} '==' |
	//	{expressions::NonEqualNumber.left=current} '=\\=' | {expressions::GreaterThan.left=current} '>' |
	//	{expressions::GreaterOrEqual.left=current} '>=' | {expressions::StandardOrderBefore.left=current} '@<' |
	//	{expressions::EqualOrStandardOrderBefore.left=current} '@=<' | {expressions::StandardOrderAfter.left=current} '@>' |
	//	{expressions::EqualOrStandardOrderAfter.left=current} '@>=' | {expressions::NotUnifiable.left=current} '\\=' |
	//	{expressions::Disequality.left=current} '\\==' | {expressions::As.left=current} 'as' | {expressions::Is.left=current}
	//	'is' | {expressions::ParticalUnification.left=current} '>:<' | {expressions::SubDict.left=current} ':<')
	//	right=Expression_600_xfy)?;
	public PrologGrammarAccess.Expression_700_xfxElements getExpression_700_xfxAccess() {
		return gaProlog.getExpression_700_xfxAccess();
	}
	
	public ParserRule getExpression_700_xfxRule() {
		return getExpression_700_xfxAccess().getRule();
	}
	
	//// 600, infix, right-associative
	//Expression_600_xfy expressions::Expression:
	//	Expression_500_yfx ({expressions::ModuleCall.left=current} ':' right=Expression_600_xfy)?;
	public PrologGrammarAccess.Expression_600_xfyElements getExpression_600_xfyAccess() {
		return gaProlog.getExpression_600_xfyAccess();
	}
	
	public ParserRule getExpression_600_xfyRule() {
		return getExpression_600_xfyAccess().getRule();
	}
	
	//// 500, infix, left-associative
	//Expression_500_yfx expressions::Expression:
	//	Expression_400_yfx (({expressions::Plus.left=current} '+' | {expressions::Minus.left=current} '-' |
	//	{expressions::BinaryAnd.left=current} '/\\' | {expressions::BinaryOr.left=current} '\\/' |
	//	{expressions::Xor.left=current} 'xor') right=Expression_400_yfx)*;
	public PrologGrammarAccess.Expression_500_yfxElements getExpression_500_yfxAccess() {
		return gaProlog.getExpression_500_yfxAccess();
	}
	
	public ParserRule getExpression_500_yfxRule() {
		return getExpression_500_yfxAccess().getRule();
	}
	
	//// 500, prefix, non-associative
	///*
	//Expression_500_fx returns expressions::Expression:
	//	Expression_400_yfx | ('?' expr=Expression_400_yfx)
	//;
	//*/ // 400, infix, left-associative
	//Expression_400_yfx expressions::Expression:
	//	Expression_200_xfy (({expressions::Multiplication.left=current} '*' | {expressions::Division.left=current} '/' |
	//	{expressions::IntegerDivision.left=current} '//' | {expressions::Div.left=current} 'div' |
	//	{expressions::Rdiv.left=current} 'rdiv' | {expressions::BitwiseShiftLeft.left=current} '<<' |
	//	{expressions::Mod.left=current} 'mod' | {expressions::Rem.left=current} 'rem') right=Expression_200_xfy)*;
	public PrologGrammarAccess.Expression_400_yfxElements getExpression_400_yfxAccess() {
		return gaProlog.getExpression_400_yfxAccess();
	}
	
	public ParserRule getExpression_400_yfxRule() {
		return getExpression_400_yfxAccess().getRule();
	}
	
	//// 200, infix, non-associative
	///*
	//Expression_200_xfx returns Expression:
	//	Expression_200_xfy ({Expression_200_xfx.left=current} '**' right=Expression_200_xfy)?
	//;
	//*/ // 200, infix, right-associative
	//Expression_200_xfy expressions::Expression:
	//	Expression_200_fy ({expressions::Power.left=current} '^' right=Expression_200_xfy)?;
	public PrologGrammarAccess.Expression_200_xfyElements getExpression_200_xfyAccess() {
		return gaProlog.getExpression_200_xfyAccess();
	}
	
	public ParserRule getExpression_200_xfyRule() {
		return getExpression_200_xfyAccess().getRule();
	}
	
	//// 200, prefix, right-associative
	//Expression_200_fy expressions::Expression:
	//	Expression_Primary | ({expressions::PositiveNumber} '+' | {expressions::NegativeNumber} '-' |
	//	{expressions::BitwiseNegation} '\\') expr=Expression_200_fy;
	public PrologGrammarAccess.Expression_200_fyElements getExpression_200_fyAccess() {
		return gaProlog.getExpression_200_fyAccess();
	}
	
	public ParserRule getExpression_200_fyRule() {
		return getExpression_200_fyAccess().getRule();
	}
	
	//Expression_Primary expressions::Expression:
	//	'(' Expression_1100_xfy ')' | Term;
	public PrologGrammarAccess.Expression_PrimaryElements getExpression_PrimaryAccess() {
		return gaProlog.getExpression_PrimaryAccess();
	}
	
	public ParserRule getExpression_PrimaryRule() {
		return getExpression_PrimaryAccess().getRule();
	}
	
	//terminal PROLOG_ID:
	//	('a'..'z' | 'A'..'Z' | '_') ('a'..'z' | 'A'..'Z' | '_' | '0'..'9')*;
	public TerminalRule getPROLOG_IDRule() {
		return gaProlog.getPROLOG_IDRule();
	}
	
	//terminal PROLOG_STRING:
	//	"'" !"'"* "'";
	public TerminalRule getPROLOG_STRINGRule() {
		return gaProlog.getPROLOG_STRINGRule();
	}
	
	//terminal PROLOG_SL_COMMENT:
	//	'%' !('\n' | '\r')* ('\r'? '\n')?;
	public TerminalRule getPROLOG_SL_COMMENTRule() {
		return gaProlog.getPROLOG_SL_COMMENTRule();
	}
	
	//terminal INT returns ecore::EInt:
	//	'0'..'9'+;
	public TerminalRule getINTRule() {
		return gaProlog.getINTRule();
	}
	
	//terminal WS:
	//	' ' | '\t' | '\r' | '\n'+;
	public TerminalRule getWSRule() {
		return gaProlog.getWSRule();
	}
}
